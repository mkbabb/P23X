Test date: 04/21/21  15:49:07 
The number of times you used the grading program is 4 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
ARM Grading System Version 4.2
Student: St#1=Babb                 St#2t=Cheerla              Type=Team                
Grading program history
   *** Grading Run.  Date: 04/21/21  13:49:29 
   *** Grading Run.  Date: 04/21/21  15:47:06 
   *** Grading Run.  Date: 04/21/21  15:47:40 
   *** Grading Run.  Date: 04/21/21  15:49:07 
Comparing your program's key.out to the expected output
Test ran correctly.
++ Grade ++  100 = Points earned for correct answers.

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++  100 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
     4  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC766&}xC6&k~C6&juiC6&zuzC766&Zkyz&jgzk@&6:587587&&7;@:?@6=&

Building the file arm.ans for electronic submission...

         .equ SWI_Open,  0x66     	
         .equ SWI_Close, 0x68     	
         .equ SWI_PrStr, 0x69     	
         .equ SWI_RdStr, 0x6a     	
         .equ SWI_Exit,  0x11     	
@----------------------------------
         .global   _start
         .text

_start:
@----------------------------------
         ldr  r0, =InFileName     	
         ldr  r1, =0              	
         swi  SWI_Open            	
         ldr  r1, =InFileHandle   	
         str  r0, [r1]            	
@----------------------------------
         ldr  r0, =OutFileName    	
         ldr  r1, =1              	
         swi  SWI_Open            	
         ldr  r1, =OutFileHandle  	
         str  r0, [r1]            	
@----------------------------------
_process:
         ldr  r0, =InFileHandle   	
         ldr  r0, [r0]            	
         ldr  r1, =InString       	
         ldr  r2, =80           	
         swi  SWI_RdStr           	
		 cmp r0, #0x00				
		 beq _exit					
@----------------------------------
         ldr  r0, =InString       	
         ldr  r1, =OutString      	
_loop:                            	
        ldrb r2, [r0], #1        	
        cmp r2, #0x00				
        beq _finloop				

        cmp r2, #' '
        beq _store

        and r2, r2, #0xdf               ; bit-twiddling caps trick.
        sub r3, r2, #'A'                 ; in the range 'twixt [A, Z]?
        cmp r3, #25                     ; does the cmp above the above.
        bls _store 

        b _loop                ; jmp if so.	 		
				
_store:								
        strb r2, [r1], #1        	
		b _loop						
_finloop: 							
		strb r2, [r1]				
@----------------------------------
_print:
         ldr  r0, =OutFileHandle  	
         ldr  r0, [r0]            	
         ldr  r1, =OutString      	
         swi  SWI_PrStr           	
         ldr  r1, =CRLF           	
         swi  SWI_PrStr           	
		 b _process					
@----------------------------------
_exit:                            	
         swi  SWI_Exit            	
@----------------------------------
         .data
@----------------------------------
InFileHandle:  .skip 4            	
OutFileHandle: .skip 4            	
									
InFileName:    .asciz "KEY.IN"   	
									
InString:      .skip 80          	
OutString:     .skip 80          	
									
CRLF:          .byte 13, 10, 0    	
									
OutFileName:   .asciz "KEY.OUT"  	
@----------------------------------
         .end